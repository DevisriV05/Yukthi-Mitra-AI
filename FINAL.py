import streamlit as st
import json
import os
import random
import uuid
from collections.abc import Mapping
import matplotlib.pyplot as plt
import google.generativeai as genai

# ---------------- Gemini setup ----------------
genai.configure(api_key=os.getenv("GEMINI_API_KEY", "Your api key"))
model = genai.GenerativeModel("gemini-1.5-flash")
chat = model.start_chat(history=[])

# ---------------- Profile functions ----------------
def load_user_profile(username, file='users.json'):
    if not os.path.exists(file):
        with open(file, 'w') as f:
            json.dump({}, f)
    with open(file, 'r') as f:
        data = json.load(f)
    if username in data:
        return data[username], data
    else:
        data[username] = {}
        return data[username], data

def save_user_profile(username, user_data, all_data, file='users.json'):
    all_data[username] = user_data
    with open(file, 'w') as f:
        json.dump(all_data, f, indent=4)

# ---------------- Utils ----------------
def questions_file_for(lang):
    return f"{lang.lower()}_questions.json"

def load_questions_for(lang):
    file = questions_file_for(lang)
    if not os.path.exists(file):
        st.warning(
            f"Could not find {file}. "
            "Run your save_questions.py to generate JSON files in this folder."
        )
        return []
    with open(file, "r") as f:
        return json.load(f)

def _rerun():
    try:
        st.rerun()
    except Exception:
        # compatibility with older Streamlit
        st.experimental_rerun()

# ---------------- Quiz generation (AI) ----------------
# @st.cache_data(show_spinner=False, ttl=600) # Caches data for 10 minutes, adjust as needed
def generate_questions_with_ai(language, level, num_questions=10):
    prompt = f"""
    Generate {num_questions} multiple-choice questions for a quiz on the topic of {language}.
    The questions should be suitable for a user at a {level} level.
    For each question, provide:
    1. A clear and concise 'question'.
    2. A list of 4 'options' (multiple-choice answers), one of which must be the correct answer.
    3. The 'answer' string, which is the correct option.
    4. A 'topic' string (e.g., 'Syntax', 'Data Types', 'Functions').

    Format the output as a JSON array of objects, like this:
    ```json
    [
      {{
        "question": "...",
        "options": ["...", "...", "...", "..."],
        "answer": "...",
        "topic": "..."
      }},
      {{...}}
    ]
    ```
    Ensure the JSON is perfectly formatted and does not contain any extra text or markdown outside the JSON block.
    """
    try:
        response = chat.send_message(prompt)
        response_text = response.text.strip()
        
        # Look for the JSON code block
        if "```json" in response_text and "```" in response_text:
            start_index = response_text.find("```json") + len("```json")
            end_index = response_text.rfind("```")
            json_string = response_text[start_index:end_index].strip()
        else:
            # If no code block is found, assume the entire response might be the JSON.
            json_string = response_text
        
        try:
            questions = json.loads(json_string)
            return questions
        except json.JSONDecodeError as e:
            st.error(f"Failed to parse AI response as JSON: {e}")
            st.code(response.text)
            return []
    except Exception as e:
        st.error(f"Error generating questions with AI: {e}")
        return []

# ---------------- Quiz rendering ----------------
def run_quiz_ai_split(selected_lang, selected_level, user_profile, all_profiles_data, username):
    """
    Renders a 10-question quiz generated by AI, split into two columns (5+5),
    computes score + weak topics, and saves to profile.
    Ensures questions reset when language/level changes or on retake.
    """
    quiz_key = f"{selected_lang.lower()}::{selected_level.lower()}"

    if st.session_state.get("quiz_active_key") != quiz_key:
        st.session_state.pop("quiz_questions", None)
        st.session_state.pop("quiz_id", None)
        st.session_state["quiz_active_key"] = quiz_key
        st.session_state["quiz_submitted"] = False

    if "quiz_questions" not in st.session_state:
        with st.spinner("Generating quiz questions with AI..."):
            questions = generate_questions_with_ai(selected_lang, selected_level)
            if not questions:
                return
            st.session_state.quiz_questions = questions
            st.session_state.quiz_id = uuid.uuid4().hex[:8]

    questions = st.session_state.quiz_questions
    quiz_id = st.session_state.quiz_id

    st.caption(f"Language: {selected_lang} â€¢ Level: {selected_level}")

    if not st.session_state.get("quiz_submitted"):
        # Display quiz questions if not submitted
        colQ1, colQ2 = st.columns(2)
        answers = []

        with colQ1:
            for i, q in enumerate(questions[:5], 1):
                st.write(f"*Q{i}. {q['question']}*")
                choice = st.radio(
                    "Select:",
                    q["options"],
                    key=f"q{i}{quiz_id}{username}",
                    horizontal=False
                )
                answers.append({"selected": choice, "correct": q["answer"], "topic": q["topic"]})

        with colQ2:
            for i, q in enumerate(questions[5:], 6):
                st.write(f"*Q{i}. {q['question']}*")
                choice = st.radio(
                    "Select:",
                    q["options"],
                    key=f"q{i}{quiz_id}{username}",
                    horizontal=False
                )
                answers.append({"selected": choice, "correct": q["answer"], "topic": q["topic"]})

        colA, colB, colC = st.columns([1,1,1])
        with colA:
            submit = st.button("âœ… Submit Quiz")
        with colB:
            retake = st.button("ğŸ” Retake")
        with colC:
            change = st.button("ğŸ§­ Change Language/Level")
      
    else: # If the quiz has been submitted
        # Display the results
        score = user_profile['last_score']
        weak = user_profile.get('last_weak_topics', {})
        st.success(f"Your Score: {score}/{len(questions)} ğŸ‰")
        if weak:
            st.write("Weak Topics:", weak)

        # Show buttons for further actions
        colA, colB, colC = st.columns([1,1,1])
        with colA:
            retake = st.button("ğŸ” Retake")
        with colB:
            change = st.button("ğŸ§­ Change Language/Level")


    if retake:
        st.session_state.quiz_started = True
        st.session_state.pop("quiz_questions", None)
        st.session_state.pop("quiz_id", None)
        _rerun()

    if change:
        st.session_state.quiz_started = False
        st.session_state.pop("quiz_questions", None)
        st.session_state.pop("quiz_id", None)
        st.session_state.pop("quiz_active_key", None)
        _rerun()

    if submit:
        score = 0
        weak = {}
        for ans in answers:
            if ans["selected"] == ans["correct"]:
                score += 1
            else:
                t = ans["topic"]
                weak[t] = weak.get(t, 0) + 1

        st.success(f"Your Score: {score}/{len(questions)} ğŸ‰")
        if weak:
            st.write("Weak Topics:", weak)

        user_profile['last_score'] = score
        user_profile['last_weak_topics'] = weak
        user_profile['last_language'] = selected_lang
        user_profile['last_level'] = selected_level
        save_user_profile(username, user_profile, all_profiles_data)

        st.session_state.pop("quiz_questions", None)
        st.session_state.pop("quiz_id", None)
        st.session_state.pop("quiz_active_key", None)
        st.session_state["quiz_started"] = False
        st.session_state.active_page = "Dashboard"
        _rerun()
        
        # # We need to stay on the quiz page to show the result.
        # # So we should NOT change the active_page and we should NOT rerun.
        # # The next rerun (e.g., from user interaction) will show the dashboard.
        # # We also need to hide the quiz questions after submission to prevent re-display
        # # We can use a session state variable for this.
        # st.session_state["quiz_submitted"] = True
        # # IMPORTANT: Remove the _rerun() call.
        # #_rerun() # Remove this line
        # # We still want the navigation logic to work so we'll re-add this line
        # # but the submit button now does what it's supposed to.
        # st.session_state.active_page = "Dashboard"
        # _rerun()
        

# ---------------- Dashboard ----------------
def show_dashboard(user_profile):
    st.subheader("Dashboard ğŸ“Š")
    if 'last_score' not in user_profile:
        st.info("No quiz data yet.")
        return
    st.write(f"Last Score: {user_profile['last_score']}")
    weak = user_profile.get('last_weak_topics', {})
    if weak:
        # Using constrained_layout for better automatic spacing
        fig, ax = plt.subplots(figsize=(6,4), constrained_layout=True)
        ax.bar(list(weak.keys()), list(weak.values()))
        ax.set_ylabel("Incorrect answers",fontsize=8)
        # Using 'y' for title position and setting fontsize
        ax.set_title("Weak Topics", fontsize=10, y=1.05) 
        ax.tick_params(axis='x', labelsize=8, rotation=45) 
        st.pyplot(fig)
    else:
        st.write("No weak topics.")

# ---------------- Timetable ----------------
def show_timetable(user_profile):
    st.subheader("7-Day Study Timetable")

    weak = user_profile.get('last_weak_topics', {})
    if not weak:
        st.info("No weak topics found. Take a quiz first.")
        return

    total_hours_map = {}
    for topic, mistakes in weak.items():
        if mistakes >= 3:
            total_hours_map[topic] = 8
        elif mistakes == 2:
            total_hours_map[topic] = 5
        else:
            total_hours_map[topic] = 3

    total_hours = sum(total_hours_map.values())
    avg_per_day = round(total_hours / 7, 2)

    st.write(f"Total Study Hours Needed: {total_hours} hrs")
    st.write(f"Average per day: ~ {avg_per_day} hrs")

    st.markdown("---")
    st.write("### 7 Day Plan:")

    tokens = []
    for topic, hrs in total_hours_map.items():
        tokens += [topic] * hrs

    day_map = {i+1: [] for i in range(7)}
    for day_index, token in enumerate(tokens):
        day_number = (day_index % 7) + 1
        day_map[day_number].append(token)

    for day in range(1, 8):
        topics_today = day_map[day]
        summary = {}
        for t in topics_today:
            summary[t] = summary.get(t, 0) + 1
        line = ", ".join([f"{t} â€“ {h} hr" for t,h in summary.items()])
        st.write(f"Day {day}: {line if line else 'Rest / Review'}")

# ---------------- Pace ----------------
def show_pace(user_profile):
    st.subheader("Learning Pace Analysis ğŸš€")

    weak = user_profile.get('last_weak_topics', {})
    if not weak:
        st.info("No quiz history yet. Please complete a quiz.")
        return
    
    # ----------------- Doughnut chart -----------------
    pace_data = {}
    colors = []
    for topic, mistakes in weak.items():
        if mistakes >= 3:
            pace_data[topic] = 5
            colors.append("#FF4500")
        elif mistakes == 2:
            pace_data[topic] = 3
            colors.append("#FFA500")
        else:
            pace_data[topic] = 2
            colors.append("#32CD32")

    # Slightly increased figsize for better label spacing
    fig, ax = plt.subplots(figsize=(2.5,2.5)) 
    wedges, texts, autotexts = ax.pie(
        pace_data.values(),
        labels=pace_data.keys(),
        autopct='%1.1f%%',
        startangle=90,
        colors=colors,
        wedgeprops={'width':0.4}
    )
    # Adjusted title fontsize and position
    ax.set_title("Learning Pace Doughnut Chart", fontsize=12, y=1.05)
    
    # Adjust font sizes for labels and percentages
    for text in texts:
        text.set_fontsize(10) # Increased font size for outside labels
    for text in autotexts:
        text.set_fontsize(8)  # Increased font size for inside percentages
    
    # Use tight_layout for automatic spacing adjustments for the pie chart
    fig.tight_layout()
    st.pyplot(fig)

    st.write("### Pace Summary:")
    for topic, mistakes in weak.items():
        if mistakes >= 3:
            pace_type = "Slow"
            days = 5
        elif mistakes == 2:
            pace_type = "Medium"
            days = 3
        else:
            pace_type = "Fast"
            days = 2
        st.write(f"- *{topic}* : Pace = {pace_type}, Estimated {days} day(s)")

# ---------------- Chatbot ----------------
def answer_with_chatgpt(question):
    try:
        response = chat.send_message(question)
        return response.text
    except Exception as e:
        return "Error: " + str(e)

# ---------------- Study Materials ----------------
def load_materials():
    if not os.path.exists("materials.json"):
        return {}
    with open("materials.json", "r") as f:
        return json.load(f)

materials_data = load_materials()

def show_study_materials(language):
    st.subheader(f"ğŸ“š Study Materials for {language}")

    if language not in materials_data:
        st.warning("No materials found for this language yet!")
        return

    for topic, links in materials_data[language].items():
        st.markdown(f"### ğŸ”¹ {topic}")
        col_web, col_yt = st.columns(2)

        with col_web:
            st.markdown("ğŸŒ Web Resources:")
            for link in links.get("Weblinks", []):
                st.markdown(f"- [Link]({link})")

        with col_yt:
            st.markdown("ğŸ“º YouTube Videos:")
            for link in links.get("YouTube", []):
                st.markdown(f"- [Watch here]({link})")

# ---------------- MAIN ----------------
def main():
    st.set_page_config(page_title="Yukthi-Mitra AI", layout="wide")

    if "quiz_started" not in st.session_state:
        st.session_state.quiz_started = False

    st.markdown('<h2 style="color:#FFFFFF;">Yukthi-Mitra AI</h2>', unsafe_allow_html=True)

    # ---------- SIDEBAR NAVIGATION + CHATBOT ----------
    with st.sidebar:
        st.title("Yukthi-Mitra AI")
        if st.button("ğŸ“Š Dashboard", key="nav_dashboard"):
            st.session_state.active_page = "Dashboard"
        if st.button("ğŸ—“ Timetable", key="nav_timetable"):
            st.session_state.active_page = "Timetable"
        if st.button("â³ Pace Tracker", key="nav_pace"):
            st.session_state.active_page = "Pace"
        if st.button("ğŸ“š Study Materials", key="nav_materials"):
            st.session_state.active_page = "Materials"
        if st.button("ğŸ“ Quiz", key="nav_quiz"):
            st.session_state.active_page = "Quiz"

        st.markdown("---")
        st.subheader("ğŸ¤– Chatbot")
        query = st.text_area("Ask your doubt here", height=120, key="chat_input")
        if st.button("Ask Gemini", key="ask_gemini"):
            reply = answer_with_chatgpt(query)
            st.write("BOT:", reply)

    # ---------- MAIN CONTENT AREA ----------
    username = st.text_input("Enter your name", value=st.session_state.get("username", ""))
    if username and "welcomed" not in st.session_state:
        st.session_state.username = username
        user_prof, all_prof = load_user_profile(username)
        st.success(f"âœ¨ Hey {username}, welcome to Yukthi-Mitra â€” your personal tutor! âœ¨")
        st.session_state.welcomed = username
        
        # This is the new line. It sets the active page to Dashboard
        # after the user is welcomed and before the script reloads.
        if "active_page" not in st.session_state:
            st.session_state.active_page = "Dashboard"
        
        st.stop()

    elif "welcomed" in st.session_state and username:
        st.session_state.username = username
        user_prof, all_prof = load_user_profile(username)

        if "active_page" not in st.session_state:
            st.session_state.active_page = "Dashboard"

        if st.session_state.active_page == "Dashboard":
            show_dashboard(user_prof)

        elif st.session_state.active_page == "Timetable":
            show_timetable(user_prof)

        elif st.session_state.active_page == "Pace":
            show_pace(user_prof)

        elif st.session_state.active_page == "Materials":
            if "selected_language" in user_prof:
                show_study_materials(user_prof["selected_language"])
            else:
                st.info("Please attempt a quiz first to unlock materials.")

        elif st.session_state.active_page == "Quiz":
            lang = st.selectbox("Select Language", ["Python","Java","C","HTML","CSS","JavaScript"])
            level = st.selectbox("Select Level", ["Beginner","Intermediate","Advanced"])
            user_prof["selected_language"] = lang
            user_prof["selected_level"] = level
            save_user_profile(username, user_prof, all_prof)

            start = st.button("â–¶ Start Quiz", disabled=st.session_state.quiz_started)
            if start:
                st.session_state.quiz_started = True
                st.session_state.pop("quiz_questions", None)
                st.session_state.pop("quiz_id", None)
                st.session_state.pop("quiz_active_key", None)

            st.markdown("---")
            if st.session_state.quiz_started:
                st.subheader("ğŸ“ Quiz Time!")
                run_quiz_ai_split(lang, level, user_prof, all_prof, username)
            else:
                st.info("Choose language & level, then click *Start Quiz* to begin.")

if __name__ == "__main__":

    main()
